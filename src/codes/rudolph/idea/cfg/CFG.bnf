{
  parserClass="codes.rudolph.idea.cfg.parser.CFGParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="CFG"
  psiImplClassSuffix="Impl"
  psiPackage="codes.rudolph.idea.cfg.psi"
  psiImplPackage="codes.rudolph.idea.cfg.psi.impl"

  elementTypeHolderClass="codes.rudolph.idea.cfg.psi.CFGTypes"
  elementTypeClass="codes.rudolph.idea.cfg.psi.CFGElementType"
  tokenTypeClass="codes.rudolph.idea.cfg.psi.CFGTokenType"
  
  tokens = [
      MODULE_DEF="module"
      IMPORT_DEF="import"
      ALIAS_OP="as"
      
      COMMENT="regexp:#[^\r\n]*"
      
      RUL_OP=":"
      SUB_MODULE_OP="."
      RNG_OP="-"
      ALT_OP="|"
      EXC_OP="/"
      
      GR_OPEN="("
      GR_CLOSE=")"
      
      OPT_OPEN="["
      OPT_CLOSE="]"
      
      REP_OPEN="{"
      REP_CLOSE="}"
      REP_MIN_CLOSE=">"
      REP_MAX_OPEN="<"
      REP_DELIM="$"
      INFINITE="*"
      DEFINITION_END=";"
      
      UNICODE_TOK="regexp:\\u[0-9A-Fa-f]{4}"
      STRING_TOK="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
      NATURAL_NUMBER="regexp:(0|[1-9][0-9]*)"
      NON_ZERO_NATURAL_NUMBER="regexp:[1-9][0-9]*"
      ID='regexp:[A-Za-z_][A-Za-z_0-9]*'

      space='regexp:\s+'
  ]
}

ContextFreeGrammar ::= COMMENT* ModuleDefinition (ImportDefinition | COMMENT)* (RuleDefinition | COMMENT)*

ModuleDefinition ::= MODULE_DEF FullQualifiedRuleOrModuleName DEFINITION_END {pin="MODULE_DEF"}
ImportDefinition ::= IMPORT_DEF FullQualifiedRuleOrModuleName [ALIAS_OP FullQualifiedRuleOrModuleName] DEFINITION_END {pin="IMPORT_DEF"}
RuleDefinition ::= ID RUL_OP Expression DEFINITION_END {pin="RUL_OP"}

// Binary Recursive Operators: From least to most binding:
// - Exclusion: A / B
// - Alternative: A | B
// - Sequence: A B
// - Range: A - B
//
// That means:
// - A / B C   <=> A / (B C)
// - A B / C   <=> (A B) / C
// - A | B / C <=> (A | B) / C
// - A / B | C <=> A / (B | C)
// - A B | C   <=> (A B) | C
// - A | B C   <=> A | (B C)
// - A - B C   <=> (A - B) C
// - A B - C   <=> A (B - C)
// - A - B | C <=> (A - B) | C
// - A | B - C <=> A | (B - C)
// - A - B / C <=> (A - B) / C
// - A / B - C <=> A / (B - C)
Expression ::= Exclusion

Exclusion ::= Alternative [EXC_OP Alternative] {extends=Expression pin(".*")="EXC_OP"}

Alternative ::= Sequence (ALT_OP Sequence)* {extends=Expression pin(".*")="ALT_OP"}
              
Sequence ::= Range+ {extends=Expression}
           
Range ::= Unary [RNG_OP Unary] {extends=Expression pin(".*")="RNG_OP"}

Unary ::= Terminal
        | FullQualifiedRuleOrModuleName
        | Optional
        | DelimitedRepetition
        | Group {extends=Expression}

Terminal ::= String
           | Unicode {extends=Unary}
           
String ::= STRING_TOK {extends=Terminal}
Unicode ::= UNICODE_TOK {extends=Terminal}

FullQualifiedRuleOrModuleName ::= ID (SUB_MODULE_OP ID)* {extends=Unary pin(".*")="SUB_MODULE_OP"}

Optional ::= OPT_OPEN Expression OPT_CLOSE {extends=Unary pin="OPT_OPEN"}

DelimitedRepetition ::= REP_OPEN [Min] Expression [Delimiter] [Max] REP_CLOSE {extends=Unary pin="REP_OPEN"}
Min ::= NATURAL_NUMBER REP_MIN_CLOSE {pin="NATURAL_NUMBER"}
Delimiter ::= REP_DELIM Expression {pin="REP_DELIM"}

Max ::= REP_MAX_OPEN MaxValue {pin="REP_MAX_OPEN"}
MaxValue ::= MaxValueNumber
           | MaxValueInfinite
MaxValueNumber ::= NON_ZERO_NATURAL_NUMBER {extends=MaxValue}
MaxValueInfinite ::= INFINITE {extends=MaxValue}

Group ::= GR_OPEN Expression GR_CLOSE {extends=Unary pin="GR_OPEN"}